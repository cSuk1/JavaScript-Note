ES6 新增的“弱映射（WeakMap）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。WeakMap 是 Map 的“兄弟类型””，其 API 也是 Map 的子集。WeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。

在 JavaScript 中，WeakMap 是一种特殊类型的映射（Map）数据结构，它允许将对象作为键存储和检索相应的值。与普通的 Map 不同，WeakMap 中的键只能是对象，而不能是原始值（如字符串、数字或布尔值）。

WeakMap 的名称中的 "Weak" 指的是键的弱引用特性。这意味着当对象作为键被存储在 WeakMap 中时，它们不会阻止被垃圾回收器回收内存。换句话说，如果一个对象作为键被存储在 WeakMap 中，而且在其他地方没有被引用，那么在垃圾回收时，该对象可能会被自动从 WeakMap 中删除。

由于键的弱引用特性，WeakMap 有一些限制和特殊行为：

1. 键必须是对象：WeakMap 的键只能是对象，不能是原始值。这是因为原始值没有弱引用特性，无法被垃圾回收器自动清理。
2. 无法遍历：由于 WeakMap 中的键是弱引用，无法直接获取所有键的列表或进行遍历。这是为了保护对象的隐私和安全性。
3. 方法和功能较少：WeakMap 的方法和功能相对有限。它没有像 Map 那样的迭代方法（如 `forEach`和 `keys`），也没有 `size`属性。

WeakMap 的主要用途是在需要将额外数据与对象关联起来，但又不希望阻止对象被垃圾回收时使用。常见的应用场景包括缓存、附加数据和私有数据存储。

在 JavaScript 中，对象不再被引用的情况有几种：

1. 超出作用域：当 `person` 对象在某个函数或块级作用域中创建，并在该作用域之外不再被引用时，垃圾回收器可以回收该对象。例如，如果 `person` 对象是在函数内部创建的，并且函数执行完毕后没有将其传递给其他函数或存储在全局变量中，那么在函数执行完毕后，`person` 对象就不再被引用。
2. 解除引用：如果你在代码中显式地将 `person` 对象设为 `null` 或解除其他对它的引用，那么垃圾回收器可以检测到该对象不再被引用，并在适当时回收它。
3. 闭包中的引用：如果 `person` 对象被一个闭包引用，即使在外部作用域中没有对它的引用，它仍然会被认为是可达的，并且垃圾回收器不会回收它。只有当闭包本身不再被引用时，才会释放对 `person` 对象的引用。
